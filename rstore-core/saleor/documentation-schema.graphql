schema {
    query: Query
    mutation: Mutation
}

type Address implements Node {
    # The ID of the object.
    id: ID!
    firstName: String!
    lastName: String!
    companyName: String!
    streetAddress1: String!
    streetAddress2: String!
    city: String!
    cityArea: String!
    postalCode: String!
    #Default country
    country: CountryDisplay!
    countryArea: String!
    phone: String
    # Address is user's default shipping address.
    isDefaultShippingAddress: Boolean
    # Address is user's default billing address.
    isDefaultBillingAddress: Boolean
}

input AddressInput {
    # Given name.
    firstName: String
    # Family name.
    lastName: String
    # Company or organization.
    companyName: String
    # Address.
    streetAddress1: String
    # Address.
    streetAddress2: String
    # City.
    city: String
    # District.
    cityArea: String
    # Postal code.
    postalCode: String
    # Country.
    country: CountryCode
    # State or province.
    countryArea: String
    # Phone number.
    phone: String
}

type Category implements Node, ObjectWithMetadata {
    # The ID of the object.
    id: ID!
    name: String!
    description: String!
    slug: String!
    # List of private metadata items.Requires proper staff permissions to access.
    privateMetadata: [MetadataItem]!
    # List of public metadata items. Can be accessed without permissions.
    metadata: [MetadataItem]!
}

type CategoryCountableConnection {
    # Pagination data for this connection.
    pageInfo: PageInfo!
    edges: [CategoryCountableEdge!]!
    # A total count of items in the collection.
    totalCount: Int
}

type CategoryCountableEdge {
    # The item at the end of the edge.
    node: Category!
    # A cursor for use in pagination.
    cursor: String!
}

type Collection implements Node, ObjectWithMetadata {
    # The ID of the object.
    id: ID!
    name: String!
    description: String!
    slug: String!
    # List of private metadata items.Requires proper staff permissions to access.
    privateMetadata: [MetadataItem]!
    # List of public metadata items. Can be accessed without permissions.
    metadata: [MetadataItem]!
}

type CollectionCountableConnection {
    # Pagination data for this connection.
    pageInfo: PageInfo!
    edges: [CollectionCountableEdge!]!
    # A total count of items in the collection.
    totalCount: Int
}

type CollectionCountableEdge {
    # The item at the end of the edge.
    node: Collection!
    # A cursor for use in pagination.
    cursor: String!
}

enum CountryCode {
    AF
    AX
    AL
    DZ
    AS
    AD
    AO
    AI
    AQ
    AG
    AR
    AM
    AW
    AU
    AT
    AZ
    BS
    BH
    BD
    BB
    BY
    BE
    BZ
    BJ
    BM
    BT
    BO
    BQ
    BA
    BW
    BV
    BR
    IO
    BN
    BG
    BF
    BI
    CV
    KH
    CM
    CA
    KY
    CF
    TD
    CL
    CN
    CX
    CC
    CO
    KM
    CG
    CD
    CK
    CR
    CI
    HR
    CU
    CW
    CY
    CZ
    DK
    DJ
    DM
    DO
    EC
    EG
    SV
    GQ
    ER
    EE
    SZ
    ET
    EU
    FK
    FO
    FJ
    FI
    FR
    GF
    PF
    TF
    GA
    GM
    GE
    DE
    GH
    GI
    GR
    GL
    GD
    GP
    GU
    GT
    GG
    GN
    GW
    GY
    HT
    HM
    VA
    HN
    HK
    HU
    IS
    IN
    ID
    IR
    IQ
    IE
    IM
    IL
    IT
    JM
    JP
    JE
    JO
    KZ
    KE
    KI
    KW
    KG
    LA
    LV
    LB
    LS
    LR
    LY
    LI
    LT
    LU
    MO
    MG
    MW
    MY
    MV
    ML
    MT
    MH
    MQ
    MR
    MU
    YT
    MX
    FM
    MD
    MC
    MN
    ME
    MS
    MA
    MZ
    MM
    NA
    NR
    NP
    NL
    NC
    NZ
    NI
    NE
    NG
    NU
    NF
    KP
    MK
    MP
    NO
    OM
    PK
    PW
    PS
    PA
    PG
    PY
    PE
    PH
    PN
    PL
    PT
    PR
    QA
    RE
    RO
    RU
    RW
    BL
    SH
    KN
    LC
    MF
    PM
    VC
    WS
    SM
    ST
    SA
    SN
    RS
    SC
    SL
    SG
    SX
    SK
    SI
    SB
    SO
    ZA
    GS
    KR
    SS
    ES
    LK
    SD
    SR
    SJ
    SE
    CH
    SY
    TW
    TJ
    TZ
    TH
    TL
    TG
    TK
    TO
    TT
    TN
    TR
    TM
    TC
    TV
    UG
    UA
    AE
    GB
    UM
    US
    UY
    UZ
    VU
    VE
    VN
    VG
    VI
    WF
    EH
    YE
    ZM
    ZW
}

type CountryDisplay {
    # Country code.
    code: String!
    # Country name.
    country: String!
}

type CreateNewOrder {
    orderErrors: [OrderError!]!
    order: Order
}

input CreateNewOrderInput {
    # Phone number of the user. This field is required if userEmail field is not set.
    userPhone: String
    # Email of the user. This field is required if userPhone field is not set.
    userEmail: String
    # Actual order ID generated by the partner's system for the order.
    # This field is required.
    # It is used to track the original order in the partner's system.
    partnerOrderId: String!
    # Billing address of the user. This field is optional.
    # If not provided, the default billing address of the user will be used.
    # Example:
    # {
    # "firstName": "Rakib",
    # "lastName": "Hasan"
    # "city": "Dhaka",
    # "cityArea": "Mirpur",
    # "streetAddress1": "240/A, minhaj road",
    # "postalCode": "1216",
    # "phone": "018********"
    # }
    # All the fields in the example are not required.
    billingAddress: AddressInput
    # Shipping address of the user. This field is optional.
    # If not provided, the default shipping address of the user will be used.
    # Example:
    # {
    # "firstName": "Rakib",
    # "lastName": "Hasan"
    # "city": "Dhaka",
    # "cityArea": "Mirpur",
    # "streetAddress1": "240/A, minhaj road",
    # "postalCode": "1216",
    # "phone": "018********"
    # }
    # All the fields in the example are not required.
    shippingAddress: AddressInput
    # A note from a user. Visible to user in the order summary.
    customerNote: String
    # List of products for the order. This field is required.
    products: [OrderProductLineInput]!
    # Status of the order's payment. This field is optional.
    # It accepts FULLY_CHARGED or NOT_CHARGED only.
    paymentStatus: PaymentChargeStatusEnum
    # Shipping method for the order. This field is optional.
    # If not provided, shipping charge is not added.
    # Here is a sample shipping input
    # {
    # "name": "xyz courier service",
    # "price": "120"
    # }
    shipping: ShippingPriceInput
    # Discount option used for the order. This field is optional.
    # Here is a sample discount input
    # {
    # "name": "new-year",
    # "code": "2021",
    # "discountValue": "20",
    # "discountValueType": "FIXED"
    # }
    # discountValueType can be FIXED or PERCENTAGE only.
    discount: VoucherInput
}

scalar Date

input DateRangeInput {
    # Start date.
    gte: Date
    # End date.
    lte: Date
}

scalar DateTime

scalar Decimal

type DigitalContent implements Node, ObjectWithMetadata {
    useDefaultSettings: Boolean!
    automaticFulfillment: Boolean!
    productVariant: ProductVariant!
    contentFile: String!
    maxDownloads: Int
    urlValidDays: Int
    # List of URLs for the digital variant.
    urls: [DigitalContentUrl]
    # The ID of the object.
    id: ID!
    # List of private metadata items.Requires proper staff permissions to access.
    privateMetadata: [MetadataItem]!
    # List of public metadata items. Can be accessed without permissions.
    metadata: [MetadataItem]!
}

type DigitalContentUrl implements Node {
    token: UUID!
    content: DigitalContent!
    created: DateTime!
    downloadNum: Int!
    # The ID of the object.
    id: ID!
    # URL for digital content.
    url: String
}

enum DiscountValueTypeEnum {
    FIXED
    PERCENTAGE
}
type Document implements Node {
    # The ID of the object.
    id: ID!
    mimetype: String!
    # Document file path.
    contentFile: String
    # Type of file
    fileTag: String!
    # Created time
    created: DateTime!
    # Updated time
    updated: DateTime!
}
type Fulfillment implements Node, ObjectWithMetadata {
    # The ID of the object.
    id: ID!
    fulfillmentOrder: Int!
    status: FulfillmentStatus!
    trackingNumber: String!
    created: DateTime!
    # List of private metadata items.Requires proper staff permissions to access.
    privateMetadata: [MetadataItem]!
    # List of public metadata items. Can be accessed without permissions.
    metadata: [MetadataItem]!
    # List of lines for the fulfillment.
    lines: [FulfillmentLine]
    # User-friendly fulfillment status.
    statusDisplay: String
    # Warehouse from fulfillment was fulfilled.
    warehouse: Warehouse
}

type FulfillmentLine implements Node {
    # The ID of the object.
    id: ID!
    quantity: Int!
    orderLine: OrderLine
}

enum FulfillmentStatus {
    # Fulfilled
    FULFILLED
    # Canceled
    CANCELED
}

type Image {
    # The URL of the image.
    url: String!
    # Alt text for an image.
    alt: String
}

scalar JSONString

type Margin {
    start: Int
    stop: Int
}

input MetadataInput {
    # Key of a metadata item.
    key: String!
    # Value of a metadata item.
    value: String!
}

type MetadataItem {
    # Key of a metadata item.
    key: String!
    # Value of a metadata item.
    value: String!
}

type Money {
    # Currency code.
    currency: String!
    # Amount of money.
    amount: Float!
}

type MoneyRange {
    # Lower bound of a price range.
    start: Money
    # Upper bound of a price range.
    stop: Money
}

type Mutation {
    # Creates a new draft order from partner.
    createNewOrder(input: CreateNewOrderInput!): CreateNewOrder
    # Updates existing order's status.
    updateOrder(input: UpdateOrderInput!): UpdateOrder
}

interface Node {
    # The ID of the object.
    id: ID!
}

interface ObjectWithMetadata {
    # List of private metadata items.Requires proper staff permissions to access.
    privateMetadata: [MetadataItem]!
    # List of public metadata items. Can be accessed without permissions.
    metadata: [MetadataItem]!
}

type Order implements Node, ObjectWithMetadata {
    # The ID of the object.
    id: ID!
    created: DateTime!
    status: OrderStatus!
    user: User
    trackingClientId: String!
    billingAddress: Address
    shippingAddress: Address
    shippingMethod: ShippingMethod
    shippingMethodName: String
    # Total price of shipping.
    shippingPrice: TaxedMoney
    token: String!
    voucher: Voucher
    discount: Money
    discountName: String
    displayGrossPrices: Boolean!
    customerNote: String!
    weight: Weight
    partnerOrderId: String
    # List of private metadata items.Requires proper staff permissions to access.
    privateMetadata: [MetadataItem]!
    # List of public metadata items. Can be accessed without permissions.
    metadata: [MetadataItem]!
    # List of shipments for the order.
    fulfillments: [Fulfillment]!
    # List of order lines.
    lines: [OrderLine]!
    # List of actions that can be performed in the current state of an order.
    actions: [OrderAction]!
    # Shipping methods that can be used with this order.
    availableShippingMethods: [ShippingMethod]
    # User-friendly number of an order.
    number: String
    # Informs if an order is fully paid.
    isPaid: Boolean
    # Internal payment status.
    paymentStatus: PaymentChargeStatusEnum
    # User-friendly payment status.
    paymentStatusDisplay: String
    # List of payments for the order.
    payments: [Payment]
    # Total amount of the order.
    total: TaxedMoney
    # The sum of line prices not including shipping.
    subtotal: TaxedMoney
    # User-friendly order status.
    statusDisplay: String
    # Informs whether a draft order can be finalized(turned into a regular order).
    canFinalize: Boolean!
    # Amount authorized for the order.
    totalAuthorized: Money
    # Amount captured by payment.
    totalCaptured: Money
    # The difference between the paid and the order total amount.
    totalBalance: Money!
    # Email address of the customer.
    userEmail: String
    # Returns True, if order requires shipping.
    isShippingRequired: Boolean!
}

enum OrderAction {
    # Represents the capture action.
    CAPTURE
    # Represents a mark-as-paid action.
    MARK_AS_PAID
    # Represents a refund action.
    REFUND
    # Represents a void action.
    VOID
}

type OrderCountableConnection {
    # Pagination data for this connection.
    pageInfo: PageInfo!
    edges: [OrderCountableEdge!]!
    # A total count of items in the collection.
    totalCount: Int
}

type OrderCountableEdge {
    # The item at the end of the edge.
    node: Order!
    # A cursor for use in pagination.
    cursor: String!
}

enum OrderDirection {
    # Specifies an ascending sort order.
    ASC
    # Specifies a descending sort order.
    DESC
}

type OrderError {
    # Name of a field that caused the error. A value of `null` indicates that the
    # error isn't associated with a particular field.
    field: String
    # The error message.
    message: String
    # The error code.
    code: OrderErrorCode!
    # Warehouse ID which causes the error.
    warehouse: ID
    # Order line ID which causes the error.
    orderLine: ID
}

enum OrderErrorCode {
    BILLING_ADDRESS_NOT_SET
    CANNOT_CANCEL_FULFILLMENT
    CANNOT_CANCEL_ORDER
    CANNOT_DELETE
    CANNOT_REFUND
    CAPTURE_INACTIVE_PAYMENT
    NOT_EDITABLE
    FULFILL_ORDER_LINE
    GRAPHQL_ERROR
    INVALID
    PRODUCT_NOT_PUBLISHED
    NOT_FOUND
    ORDER_NO_SHIPPING_ADDRESS
    PAYMENT_ERROR
    PAYMENT_MISSING
    REQUIRED
    SHIPPING_METHOD_NOT_APPLICABLE
    SHIPPING_METHOD_REQUIRED
    UNIQUE
    VOID_INACTIVE_PAYMENT
    ZERO_QUANTITY
    INSUFFICIENT_STOCK
    DUPLICATED_INPUT_ITEM
}

input OrderFilterInput {
    paymentStatus: [PaymentChargeStatusEnum]
    status: [OrderStatusFilter]
    customer: String
    created: DateRangeInput
    search: String
}

type OrderLine implements Node {
    # The ID of the object.
    id: ID!
    productName: String!
    variantName: String!
    productSku: String!
    isShippingRequired: Boolean!
    quantity: Int!
    quantityFulfilled: Int!
    taxRate: Float!
    digitalContentUrl: DigitalContentUrl
    # The main thumbnail for the ordered product.
    thumbnail(size: Int): Image
    # Price of the single item in the order line.
    unitPrice: TaxedMoney
    # A purchased product variant. Note: this field may be null if the variant has
    # been removed from stock at all.
    variant: ProductVariant
}

input OrderProductLineInput {
    # Product name.
    name: String!
    # Stock keeping unit of a product. Note: this field is only used if a product
    # doesn't use variants.
    sku: String!
    # Product price.
    basePrice: Decimal!
    # Quantity of product.
    quantity: Int!
    # Product description (HTML/text).
    description: String
    # Weight of the Product.
    weight: WeightScalar
    # Name of the product's category.
    category: String!
    # List of meta data of the product.
    metaData: [MetadataInput]
}

enum OrderSortField {
    # Sort orders by number.
    NUMBER
    # Sort orders by creation date.
    CREATION_DATE
    # Sort orders by customer.
    CUSTOMER
    # Sort orders by payment.
    PAYMENT
    # Sort orders by fulfillment status.
    FULFILLMENT_STATUS
    # Sort orders by total.
    TOTAL
}

input OrderSortingInput {
    # Specifies the direction in which to sort products.
    direction: OrderDirection!
    # Sort orders by the selected field.
    field: OrderSortField!
}

enum OrderStatus {
    # Draft
    DRAFT
    # Unfulfilled
    UNFULFILLED
    # Partially fulfilled
    PARTIALLY_FULFILLED
    # Fulfilled
    FULFILLED
    # Canceled
    CANCELED
}

enum OrderStatusFilter {
    READY_TO_FULFILL
    READY_TO_CAPTURE
    UNFULFILLED
    PARTIALLY_FULFILLED
    FULFILLED
    CANCELED
}

type PageInfo {
    # When paginating forwards, are there more items?
    hasNextPage: Boolean!
    # When paginating backwards, are there more items?
    hasPreviousPage: Boolean!
    # When paginating backwards, the cursor to continue.
    startCursor: String
    # When paginating forwards, the cursor to continue.
    endCursor: String
}

type Partner implements Node {
    # The ID of the object.
    id: ID!
    partnerName: String!
    partnerId: String!
}

type PartnerCountableConnection {
    # Pagination data for this connection.
    pageInfo: PageInfo!
    edges: [PartnerCountableEdge!]!
    # A total count of items in the collection.
    totalCount: Int
}

type PartnerCountableEdge {
    # The item at the end of the edge.
    node: Partner!
    # A cursor for use in pagination.
    cursor: String!
}

type Payment implements Node {
    # The ID of the object.
    id: ID!
    gateway: String!
    isActive: Boolean!
    created: DateTime!
    modified: DateTime!
    token: String!
    order: Order
    billingEmail: String!
    customerIpAddress: String
    extraData: String!
    # Internal payment status.
    chargeStatus: PaymentChargeStatusEnum!
    # List of actions that can be performed in the current state of a payment.
    actions: [OrderAction]!
    # Total amount of the payment.
    total: Money
    # Total amount captured for this payment.
    capturedAmount: Money
    # Customer billing address.
    billingAddress: Address
    # List of all transactions within this payment.
    transactions: [Transaction]
    # Maximum amount of money that can be captured.
    availableCaptureAmount: Money
    # Maximum amount of money that can be refunded.
    availableRefundAmount: Money
}

enum PaymentChargeStatusEnum {
    NOT_CHARGED
    PARTIALLY_CHARGED
    FULLY_CHARGED
    PARTIALLY_REFUNDED
    FULLY_REFUNDED
}

type Product implements Node, ObjectWithMetadata {
    # The ID of the object.
    id: ID!
    seoTitle: String
    seoDescription: String
    name: String!
    description: String!
    descriptionJson: JSONString!
    publicationDate: Date
    isPublished: Boolean!
    productType: ProductType!
    slug: String!
    category: Category
    updatedAt: DateTime
    chargeTaxes: Boolean!
    weight: Weight
    # List of private metadata items.Requires proper staff permissions to access.
    privateMetadata: [MetadataItem]!
    # List of public metadata items. Can be accessed without permissions.
    metadata: [MetadataItem]!
    # The main thumbnail for a product.
    thumbnail(size: Int): Image
    # Lists the storefront product's pricing, the current price and discounts, only
    # meant for displaying.
    pricing: ProductPricingInfo
    # Whether the product is in stock and visible or not.
    isAvailable: Boolean
    # The product's default base price.
    basePrice: Money
    # The price of the cheapest variant (including discounts).
    minimalVariantPrice: Money
    purchaseCost: MoneyRange
    margin: Margin
    # Get a single product image by ID.
    imageById(id: ID): ProductImage
    # List of variants for the product.
    variants: [ProductVariant]
    # List of images for the product.
    images: [ProductImage]
    # List of collections for the product.
    collections: [Collection]
}

type ProductCountableConnection {
    # Pagination data for this connection.
    pageInfo: PageInfo!
    edges: [ProductCountableEdge!]!
    # A total count of items in the collection.
    totalCount: Int
}

type ProductCountableEdge {
    # The item at the end of the edge.
    node: Product!
    # A cursor for use in pagination.
    cursor: String!
}

type ProductImage implements Node {
    # The ID of the object.
    id: ID!
    sortOrder: Int
    alt: String!
    # The URL of the image.
    url(size: Int): String!
}

type ProductPricingInfo {
    # Whether it is in sale or not.
    onSale: Boolean
    # The discount amount if in sale (null otherwise).
    discount: TaxedMoney
    # The discount amount in the local currency.
    discountLocalCurrency: TaxedMoney
    # The discounted price range of the product variants.
    priceRange: TaxedMoneyRange
    # The undiscounted price range of the product variants.
    priceRangeUndiscounted: TaxedMoneyRange
    # The discounted price range of the product variants in the local currency.
    priceRangeLocalCurrency: TaxedMoneyRange
}

type ProductType implements Node, ObjectWithMetadata {
    # The ID of the object.
    id: ID!
    name: String!
    slug: String!
    hasVariants: Boolean!
    isShippingRequired: Boolean!
    isDigital: Boolean!
    weight: Weight
    # List of private metadata items.Requires proper staff permissions to access.
    privateMetadata: [MetadataItem]!
    # List of public metadata items. Can be accessed without permissions.
    metadata: [MetadataItem]!
    # List of products of this type.
    products(before: String, after: String, first: Int, last: Int): ProductCountableConnection
}

type ProductTypeCountableConnection {
    # Pagination data for this connection.
    pageInfo: PageInfo!
    edges: [ProductTypeCountableEdge!]!
    # A total count of items in the collection.
    totalCount: Int
}

type ProductTypeCountableEdge {
    # The item at the end of the edge.
    node: ProductType!
    # A cursor for use in pagination.
    cursor: String!
}

type ProductVariant implements Node, ObjectWithMetadata {
    # The ID of the object.
    id: ID!
    name: String!
    sku: String!
    product: Product!
    trackInventory: Boolean!
    weight: Weight
    # List of private metadata items.Requires proper staff permissions to access.
    privateMetadata: [MetadataItem]!
    # List of public metadata items. Can be accessed without permissions.
    metadata: [MetadataItem]!
    # Override the base price of a product if necessary. A value of `null` indicates
    # that the default product price is used.
    priceOverride: Money
    # Lists the storefront variant's pricing, the current price and discounts, only
    # meant for displaying.
    pricing: VariantPricingInfo
    # Cost price of the variant.
    costPrice: Money
    # Gross margin percentage value.
    margin: Int
    # Total quantity ordered.
    quantityOrdered: Int
    # Total revenue generated by a variant in given period of time. Note: this field
    # should be queried using `reportProductSales` query as it uses optimizations
    # suitable for such calculations.
    revenue(period: ReportingPeriod): TaxedMoney
    # List of images for the product variant.
    images: [ProductImage]
    # Digital content for the product variant.
    digitalContent: DigitalContent
    # Quantity of a product available for sale in one checkout.
    quantityAvailable(countryCode: CountryCode): Int!
}

type Query {
    # Look up an order by ID.
    order(id: ID!): Order
    # List of orders.
    orders(sortBy: OrderSortingInput, filter: OrderFilterInput, created: ReportingPeriod, status: OrderStatusFilter, before: String, after: String, first: Int, last: Int): OrderCountableConnection
    # Return the currently authenticated user.
    me: User
}

enum ReportingPeriod {
    TODAY
    THIS_MONTH
}

type ShippingMethod implements Node {
    # The ID of the object.
    id: ID!
    name: String!
    price: Money
    minimumOrderPrice: Money
    maximumOrderPrice: Money
    minimumOrderWeight: Weight
    maximumOrderWeight: Weight
    # Type of the shipping method.
    type: ShippingMethodTypeEnum
}

enum ShippingMethodTypeEnum {
    PRICE
    WEIGHT
}

input ShippingPriceInput {
    # Name of the shipping method.
    name: String
    # Shipping price of the shipping method.
    price: Decimal
}

type ShippingZone implements Node {
    # The ID of the object.
    id: ID!
    name: String!
    default: Boolean!
    # Lowest and highest prices for the shipping.
    priceRange: MoneyRange
    # List of countries available for the method.
    countries: [CountryDisplay]
    # List of shipping methods available for orders shipped to countries within this
    # shipping zone.
    shippingMethods: [ShippingMethod]
    # List of warehouses for shipping zone.
    warehouses: [Warehouse]
}

type ShippingZoneCountableConnection {
    # Pagination data for this connection.
    pageInfo: PageInfo!
    edges: [ShippingZoneCountableEdge!]!
    # A total count of items in the collection.
    totalCount: Int
}

type ShippingZoneCountableEdge {
    # The item at the end of the edge.
    node: ShippingZone!
    # A cursor for use in pagination.
    cursor: String!
}

type TaxedMoney {
    # Currency code.
    currency: String!
    # Amount of money including taxes.
    gross: Money!
    # Amount of money without taxes.
    net: Money!
    # Amount of taxes.
    tax: Money!
}

type TaxedMoneyRange {
    # Lower bound of a price range.
    start: TaxedMoney
    # Upper bound of a price range.
    stop: TaxedMoney
}

type Transaction implements Node {
    # The ID of the object.
    id: ID!
    created: DateTime!
    payment: Payment!
    token: String!
    kind: TransactionKind!
    isSuccess: Boolean!
    error: TransactionError
    gatewayResponse: JSONString!
    # Total amount of the transaction.
    amount: Money
}

enum TransactionError {
    TRANSACTIONERROR_INCORRECT_NUMBER
    TRANSACTIONERROR_INVALID_NUMBER
    TRANSACTIONERROR_INCORRECT_CVV
    TRANSACTIONERROR_INVALID_CVV
    TRANSACTIONERROR_INCORRECT_ZIP
    TRANSACTIONERROR_INCORRECT_ADDRESS
    TRANSACTIONERROR_INVALID_EXPIRY_DATE
    TRANSACTIONERROR_EXPIRED
    TRANSACTIONERROR_PROCESSING_ERROR
    TRANSACTIONERROR_DECLINED
}

enum TransactionKind {
    # Authorization
    AUTH
    # Refund
    REFUND
    # Capture
    CAPTURE
    # Void
    VOID
    # Confirm
    CONFIRM
}

scalar UUID

type UpdateOrder {
    orderErrors: [OrderError!]!
    order: Order
}

input UpdateOrderInput {
    # Actual order ID generated by the partner's system for the order.
    # This field is required.
    # It is used to track the original order in the partner's system.
    partnerOrderId: String!
    # Status of the order's payment.
    # This field is required if orderStatus is not provided.
    # It accepts FULLY_CHARGED, FULLY_REFUNDED or NOT_CHARGED only.
    paymentStatus: PaymentChargeStatusEnum
    # Status of the order. This field is required if paymentStatus is not provided.
    # It accepts UNFULFILLED, FULFILLED or CANCELED only.
    orderStatus: OrderStatusFilter
}

type User implements Node, ObjectWithMetadata {
    # The ID of the object.
    id: ID!
    # List of public metadata items. Can be accessed without permissions.
    metadata: [MetadataItem]!
    email: String
    firstName: String!
    lastName: String!
    phone: String!
    dateJoined: DateTime!
    defaultShippingAddress: Address
    defaultBillingAddress: Address
    # List of private metadata items.Requires proper staff permissions to access.
    privateMetadata: [MetadataItem]!
    # List of all user's addresses.
    addresses: [Address]
    avatar(size: Int): Image
    # Nid front of user
    nidFront: Document
    # Nid back of user
    nidBack: Document
}

type UserCountableConnection {
    # Pagination data for this connection.
    pageInfo: PageInfo!
    edges: [UserCountableEdge!]!
    # A total count of items in the collection.
    totalCount: Int
}

type UserCountableEdge {
    # The item at the end of the edge.
    node: User!
    # A cursor for use in pagination.
    cursor: String!
}

type VariantPricingInfo {
    # Whether it is in sale or not.
    onSale: Boolean
    # The discount amount if in sale (null otherwise).
    discount: TaxedMoney
    # The discount amount in the local currency.
    discountLocalCurrency: TaxedMoney
    # The price, with any discount subtracted.
    price: TaxedMoney
    # The price without any discount.
    priceUndiscounted: TaxedMoney
    # The discounted price in the local currency.
    priceLocalCurrency: TaxedMoney
}

type Voucher implements Node {
    # The ID of the object.
    id: ID!
    name: String
    code: String!
    # Determines a type of discount for voucher - value or percentage
    discountValueType: DiscountValueTypeEnum!
    discountValue: Float!
}

input VoucherInput {
    # Voucher name.
    name: String
    # Code to use the voucher.
    code: String
    # Choices: fixed or percentage.
    discountValueType: DiscountValueTypeEnum
    # Value of the voucher.
    discountValue: Decimal
}

type Warehouse implements Node {
    # The ID of the object.
    id: ID!
    name: String!
    slug: String!
    companyName: String!
    shippingZones(before: String, after: String, first: Int, last: Int): ShippingZoneCountableConnection!
    address: Address!
    email: String!
}

type Weight {
    # Weight unit.
    unit: String!
    # Weight value.
    value: Float!
}

scalar WeightScalar
